{
    // Cyrus - IPA Syllabification Fixer for Sibelius
    // Fixes IPA syllable boundaries to match Cyrillic text in vocal scores.
    // See README.md for documentation and customization guide.

    _version "() {
        // Build version - displayed in progress dialog and report header
        return 40;
    }"
    Initialize "() {
        AddToPluginsMenu('Cyrus', 'Run');
    }"
    Run "() {
        score = Sibelius.ActiveScore;
        if (null = score) {
            Sibelius.MessageBox('No score is open.');
            return False;
        }
        result = DetectLyricStaves(score);
        if (result = null) {
            return False;
        }
        startBar = result[0];
        endBar = result[1];
        selectedStaves = result[2];
        report = ProcessScore(score, startBar, endBar, selectedStaves);
        Sibelius.MessageBox(report);
        return True;
    }"
    ProcessScore "(score, startBar, endBar, selectedStaves) {
        // Main processing loop: iterates bars then staves within each bar.
        // Returns report header with statistics.
        report = '';
        changeCount = 0;
        skippedCount = 0;
        unresolvedCount = 0;
        numStaves = CountArrayElements(selectedStaves);
        totalBars = (endBar - startBar + 1) * numStaves;
        Sibelius.CreateProgressDialog('Cyrus v' & _version(), 0, 100);
        barsDone = 0;
        cancelled = False;
        currentSection = '';
        currentPage = 1;
        // ManuScript for loops use exclusive upper bound, so +1 to include endBar
        for barNum = startBar to endBar + 1 {
            if (not(cancelled)) {
                // Get rehearsal mark from system staff for this bar
                sysBar = score.SystemStaff.NthBar(barNum);
                for each obj in sysBar {
                    if (obj.Type = 'RehearsalMark') {
                        currentSection = obj.MarkAsText;
                    }
                }
                staffIdx = 0;
                for each staff in score {
                    if (not(cancelled)) {
                        isSelected = IsStaffSelected(staff.StaffNum, selectedStaves);
                        if (isSelected) {
                            staffIdx = staffIdx + 1;
                            staffName = staff.FullInstrumentName;
                            if (staffName = '') {
                                staffName = staff.InstrumentName;
                            }
                            pct = (barsDone * 100) / totalBars;
                            progressMsg = 'Bar ' & barNum & '/' & endBar & Chr(10) & 'Staves: ' & numStaves;
                            continueProcessing = Sibelius.UpdateProgressDialog(pct, progressMsg);
                            if (not(continueProcessing)) {
                                cancelled = True;
                            } else {
                                bar = staff.NthBar(barNum);
                                displayBarNum = bar.ExternalBarNumberString;
                                if (bar.OnNthPage > 0) {
                                    currentPage = bar.OnNthPage;
                                }
                                result = ProcessBar(bar, barNum, displayBarNum, currentSection, currentPage, staffName);
                                // Parse result tags to count changes, skips, unresolved
                                counts = ParseResultCounts(result);
                                changeCount = changeCount + counts[0];
                                skippedCount = skippedCount + counts[1];
                                unresolvedCount = unresolvedCount + counts[2];
                                if (result != 'SKIP') {
                                    report = report & result;
                                }
                            }
                            barsDone = barsDone + 1;
                        }
                    }
                }
            }
        }
        Sibelius.DestroyProgressDialog();
        header = '=== Cyrus Report (build ' & _version() & ') ===' & Chr(10);
        if (cancelled) {
            Sibelius.MessageBox('Processing cancelled.');
            return header;
        }
        header = header & 'Bars: ' &(endBar - startBar + 1) & Chr(10);
        header = header & 'Staves: ' & numStaves & Chr(10);
        header = header & 'Skipped: ' & skippedCount & Chr(10);
        header = header & 'Unresolved: ' & unresolvedCount & Chr(10);
        header = header & 'Changes: ' & changeCount & Chr(10);
        // Remove internal SKIPS markers from report
        cleanReport = StripSkipMarkers(report);
        fullReport = header & Chr(10) & cleanReport;
        filePath = Sibelius.SelectFileToSave('Save Cyrus Report', 'cyrus_report.txt', '', 'txt', 'TEXT');
        if (filePath != '') {
            Sibelius.CreateTextFile(filePath);
            Sibelius.AppendTextFile(filePath, fullReport, True);
            Sibelius.MessageBox('Report saved to: ' & filePath);
        }
        return header;
    }"
    ParseResultCounts "(result) {
        // Parse result string to count CHNG, SKIPS, and UNRE occurrences.
        // Returns array: [changeCount, skipCount, unresolvedCount]
        counts = CreateSparseArray();
        counts[0] = 0;
        counts[1] = 0;
        counts[2] = 0;
        if (Length(result) >= 4) {
            for j = 0 to Length(result) - 3 {
                tag = Substring(result, j, 4);
                if (tag = 'CHNG') {
                    counts[0] = counts[0] + 1;
                }
                if (tag = 'SKIP') {
                    // SKIPS format: SKIPS123| where 123 is the count
                    endIdx = j + 5;
                    numStr = '';
                    while (endIdx < Length(result)) {
                        ch = Substring(result, endIdx, 1);
                        if (ch = '0' or ch = '1' or ch = '2' or ch = '3' or ch = '4' or ch = '5' or ch = '6' or ch = '7' or ch = '8' or ch = '9') {
                            numStr = numStr & ch;
                            endIdx = endIdx + 1;
                        } else {
                            endIdx = Length(result);
                        }
                    }
                    if (numStr != '') {
                        counts[1] = counts[1] + (0 + numStr);
                    }
                }
                if (tag = 'UNRE') {
                    counts[2] = counts[2] + 1;
                }
            }
        }
        return counts;
    }"
    StripSkipMarkers "(report) {
        // Remove internal SKIPS markers (e.g.,"
        cleanReport = '';
        i = 0;
        while (i < Length(report)) {
            if (Substring(report, i, 5) = 'SKIPS') {
    // Skip past the marker and digits until pipe
                while (i < Length(report) and Substring(report, i, 1) != '|') {
                    i = i + 1;
}
                i = i + 1;
            } else {
                cleanReport = cleanReport & Substring(report, i, 1);
                i = i + 1;
}
}
        return cleanReport;
    }"
    CountArrayElements "(arr) {
        // Count non-null elements in sparse array (up to index 999).
        count = 0;
        for i = 0 to 1000 {
            if (arr[i] = null) {
                return count;
            }
            count = count + 1;
        }
        return count;
    }"
    IsStaffSelected "(staffNum, selectedStaves) {
        // Check if staffNum is in the selectedStaves array.
        for i = 0 to 1000 {
            if (selectedStaves[i] = null) {
                return False;
            }
            if (selectedStaves[i] = staffNum) {
                return True;
            }
        }
        return False;
    }"
    ProcessBar "(bar, barNum, displayBarNum, section, page, staffName) {
        // Process all syllable boundaries in a single bar.
        // Collects Cyrillic (verse1) and IPA (verse2) lyrics at each position.
        report = '';
        skipCount = 0;
        cyrillic = CreateSparseArray();
        ipa = CreateSparseArray();
        cyrSylType = CreateSparseArray();
        for each obj in bar {
            if (obj.Type = 'LyricItem') {
                pos = obj.Position;
                style = obj.StyleId;
                if (StyleIsVerse1(style)) {
                    cyrillic[pos] = obj.Text;
                    cyrSylType[pos] = obj.SyllableType;
                } else {
                    if (StyleIsVerse2(style)) {
                        ipa[pos] = obj;
                    }
                }
            }
        }
        // Process pairs of consecutive syllables
        positions = GetSortedPositions(cyrillic);
        for i = 0 to 1000 {
            pos = positions[i];
            if (pos = null) {
                i = 1000;
            } else {
                cyrText = cyrillic[pos];
                ipaObj = ipa[pos];
                if (ipaObj != null) {
                    sylType = cyrSylType[pos];
                    // Only process middle-of-word syllables (not end-of-word)
                    if (sylType = MiddleOfWord) {
                        nextPos = positions[i + 1];
                        if (nextPos != null) {
                            nextCyrText = cyrillic[nextPos];
                            nextIpaObj = ipa[nextPos];
                            if (nextCyrText != null and nextIpaObj != null) {
                                result = ProcessSyllableBoundary(cyrText, ipaObj, nextCyrText, nextIpaObj, barNum, displayBarNum, section, page, pos, staffName);
                                if (result = 'SKIP') {
                                    skipCount = skipCount + 1;
                                } else {
                                    report = report & result;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (skipCount > 0) {
            report = 'SKIPS' & skipCount & '|' & report;
        }
        return report;
    }"
    ProcessSyllableBoundary "(cyrA, ipaObjA, cyrB, ipaObjB, barNum, displayBarNum, section, page, pos, staffName) {
        // Core algorithm: Compare Cyrillic and IPA syllable boundaries.
        // If IPA onset doesn't match expected Cyrillic-derived IPA, move consonants.
        //
        // Example: Cyrillic"
    //
    // Steps:
    // 1. Extract Cyrillic onset of second syllable (cyrB)
    // 2. Map Cyrillic onset to expected IPA
    // 3. Extract actual IPA onset (handling stress marker)
    // 4. If they match, skip (already correct)
    // 5. Calculate how many consonant units to move
    // 6. Move consonants from start of ipaB to end of ipaA
        ipaA = ipaObjA.Text;
        ipaB = ipaObjB.Text;
        cyrOnset = ExtractCyrillicOnset(cyrB);
        expectedIpa = MapCyrillicToIpa(cyrOnset);
    // Handle stress marker at start of syllable
        hasStress = False;
        ipaBWork = ipaB;
        if (Length(ipaB) > 0) {
            fc = Substring(ipaB, 0, 1);
            if (IsStressMarker(fc)) {
                hasStress = True;
                ipaBWork = Substring(ipaB, 1, Length(ipaB) - 1);
}
}
        actualOnset = ExtractIpaOnset(ipaBWork);
    // Already correct - skip
        if (OnsetMatches(actualOnset, expectedIpa)) {
            return 'SKIP';
}
    // Palatalizing vowel exception: don't move j when Cyrillic starts with я/е/ё/ю
    // These vowels inherently carry a j sound that shouldn't be separated
        if (StartsWithPalatalizingVowel(cyrB) and IsJotatedVowelOnset(ipaBWork)) {
            return 'SKIP';
}
        unitsToMove = CalculateUnitsToMove(ipaBWork, expectedIpa);
        if (unitsToMove = 0) {
            return 'SKIP';
}
    // Couldn't find a match - flag as unresolved
        if (unitsToMove < 0) {
            loc = BuildLocation(page, section, displayBarNum, pos);
            return 'UNRE ' & loc & ', ' & staffName & ': ' & ipaA & '-' & ipaB & ' (cyr: ' & cyrA & '-' & cyrB & ', expected: ' & expectedIpa & ')' & Chr(10);
}
    // Move consonant units from ipaB to ipaA
        toMove = ExtractConsonantUnits(ipaBWork, unitsToMove);
        remaining = Substring(ipaBWork, Length(toMove), Length(ipaBWork) - Length(toMove));
        newIpaA = ipaA & toMove;
        newIpaB = remaining;
    // Restore stress marker if it was present
        if (hasStress) {
            newIpaB = GetStressMarker() & newIpaB;
}
    // Apply changes to score
        ipaObjA.Text = newIpaA;
        ipaObjB.Text = newIpaB;
        loc = BuildLocation(page, section, displayBarNum, pos);
        return 'CHNG ' & loc & ', ' & staffName & ': ' & ipaA & '-' & ipaB & ' -> ' & newIpaA & '-' & newIpaB & ' (cyr: ' & cyrA & '-' & cyrB & ')' & Chr(10);
    }"
    BuildLocation "(page, section, displayBarNum, pos) {
        // Build location string for report:"
    // Sibelius uses 256 ticks per quarter note, so beat = pos/256 + 1
        beat = (pos / 256) + 1;
        loc = 'p' & page;
        if (section != '') {
            loc = loc & ' [' & section & ']';
}
        loc = loc & ' Bar ' & displayBarNum & ', Beat ' & beat;
        return loc;
    }"
    ExtractCyrillicOnset "(text) {
        // Extract consonants before first vowel in Cyrillic text.
        // Example:"
        onset = '';
        vowels = GetCyrillicVowels();
        if (Length(text) > 0) {
            for i = 0 to Length(text) {
                c = Substring(text, i, 1);
                if (CharInString(c, vowels)) {
                    return onset;
}
                onset = onset & c;
}
}
        return onset;
    }"
    MapCyrillicToIpa "(cyrOnset) {
        // Convert Cyrillic consonant cluster to expected IPA.
        // Handles special cases like сч/зч/жч -> ʃ
        if (cyrOnset = 'сч' or cyrOnset = 'зч' or cyrOnset = 'жч') {
            return 'ʃ';
        }
        result = '';
        if (Length(cyrOnset) > 0) {
            for i = 0 to Length(cyrOnset) {
                c = Substring(cyrOnset, i, 1);
                mapped = MapSingleCyrillicConsonant(c);
                result = result & mapped;
            }
        }
        return result;
    }"
    MapSingleCyrillicConsonant "(c) {
        // Map a single Cyrillic consonant to IPA equivalent.
        // Note: ч->t͡ʃ and ц->t͡s include tie bars for affricates.
        // Soft sign (ь) and hard sign (ъ) return empty string.
        if (c = 'п') {
            return 'p';
        }
        if (c = 'б') {
            return 'b';
        }
        if (c = 'т') {
            return 't';
        }
        if (c = 'д') {
            return 'd';
        }
        if (c = 'к') {
            return 'k';
        }
        if (c = 'г') {
            return 'g';
        }
        if (c = 'м') {
            return 'm';
        }
        if (c = 'н') {
            return 'n';
        }
        if (c = 'р') {
            return 'r';
        }
        if (c = 'ф') {
            return 'f';
        }
        if (c = 'в') {
            return 'v';
        }
        if (c = 'с') {
            return 's';
        }
        if (c = 'з') {
            return 'z';
        }
        if (c = 'ш') {
            return 'ʃ';
        }
        if (c = 'ж') {
            return 'ʒ';
        }
        if (c = 'щ') {
            return 'ʃ';
        }
        if (c = 'ч') {
            return 't͡ʃ';
        }
        if (c = 'ц') {
            return 't͡s';
        }
        if (c = 'й') {
            return 'j';
        }
        if (c = 'х') {
            return 'x';
        }
        if (c = 'л') {
            return 'l';
        }
        if (c = 'ь') {
            return '';
        }
        if (c = 'ъ') {
            return '';
        }
        return '';
    }"
    ExtractIpaOnset "(text) {
        // Extract consonant units before first vowel in IPA text.
        // Uses ExtractOneConsonantUnit to handle affricates and diacritics.
        onset = '';
        vowels = GetIpaVowels();
        i = 0;
        while (i < Length(text)) {
            c = Substring(text, i, 1);
            if (CharInString(c, vowels)) {
                return onset;
            }
            unit = ExtractOneConsonantUnit(text, i);
            onset = onset & unit;
            i = i + Length(unit);
        }
        return onset;
    }"
    ExtractOneConsonantUnit "(text, startIdx) {
        // Extract a single consonant unit starting at startIdx.
        // A unit includes: base consonant + optional tie bar + second consonant + diacritics
        // Examples:"
        if (startIdx >= Length(text)) {
            return '';
}
        unit = '';
        c = Substring(text, startIdx, 1);
        unit = unit & c;
        idx = startIdx + 1;
    // Check for tie bar (indicates affricate like t͡ʃ)
        if (idx < Length(text)) {
            nxt = Substring(text, idx, 1);
            if (IsTieBar(nxt)) {
                unit = unit & nxt;
                idx = idx + 1;
    // Get second consonant of affricate
                if (idx < Length(text)) {
                    nxt = Substring(text, idx, 1);
                    unit = unit & nxt;
                    idx = idx + 1;
}
}
}
    // Collect trailing diacritics (ʲ, ː, etc.)
        while (idx < Length(text)) {
            nxt = Substring(text, idx, 1);
            if (IsDiacritic(nxt)) {
                unit = unit & nxt;
                idx = idx + 1;
            } else {
                idx = Length(text);
}
}
        return unit;
    }"
    OnsetMatches "(actualOnset, expectedIpa) {
        // Compare onsets after normalization (strips diacritics, normalizes variants).
        if (expectedIpa = '') {
            return(actualOnset = '');
        }
        normalizedActual = NormalizeIpaForMatching(actualOnset);
        normalizedExpected = NormalizeIpaForMatching(expectedIpa);
        return(normalizedActual = normalizedExpected);
    }"
    NormalizeIpaForMatching "(text) {
        // Normalize IPA for comparison: strip diacritics, tie bars, and map variants.
        // ɫ (dark L) -> l, ɡ (IPA g) -> g (ASCII)
        result = '';
        if (Length(text) > 0) {
            for i = 0 to Length(text) {
                c = Substring(text, i, 1);
                if (not(IsDiacritic(c)) and not(IsTieBar(c))) {
                    if (c = 'ɫ') {
                        result = result & 'l';
                    } else {
                        if (c = 'ɡ') {
                            result = result & 'g';
                        } else {
                            result = result & c;
                        }
                    }
                }
            }
        }
        return result;
    }"
    CalculateUnitsToMove "(ipaB, expectedIpa) {
        // Calculate how many consonant units to move from ipaB onset.
        // Tries removing 0, 1, 2... units until remaining onset matches expected.
        // Returns -1 if no match found (unresolved).
        if (expectedIpa = '') {
            // No expected onset means move all consonants
            onset = ExtractIpaOnset(ipaB);
            return CountConsonantUnits(onset);
        }
        onset = ExtractIpaOnset(ipaB);
        totalUnits = CountConsonantUnits(onset);
        normalizedExpected = NormalizeIpaForMatching(expectedIpa);
        // ManuScript for loops use exclusive upper bound
        for unitsToRemove = 0 to totalUnits + 1 {
            remaining = RemoveNConsonantUnits(onset, unitsToRemove);
            normalizedRemaining = NormalizeIpaForMatching(remaining);
            if (normalizedRemaining = normalizedExpected) {
                return unitsToRemove;
            }
        }
        return -1;
    }"
    CountConsonantUnits "(text) {
        // Count consonant units in text (affricates with tie bars count as 1).
        count = 0;
        idx = 0;
        while (idx < Length(text)) {
            unit = ExtractOneConsonantUnit(text, idx);
            if (unit = '') {
                idx = Length(text);
            } else {
                count = count + 1;
                idx = idx + Length(unit);
            }
        }
        return count;
    }"
    ExtractConsonantUnits "(text, numUnits) {
        // Extract first N consonant units from text.
        result = '';
        idx = 0;
        if (numUnits > 0) {
            // ManuScript for loops use exclusive upper bound
            for u = 1 to numUnits + 1 {
                if (idx < Length(text)) {
                    unit = ExtractOneConsonantUnit(text, idx);
                    result = result & unit;
                    idx = idx + Length(unit);
                }
            }
        }
        return result;
    }"
    RemoveNConsonantUnits "(text, n) {
        // Return text with first N consonant units removed.
        idx = 0;
        if (n > 0) {
            // ManuScript for loops use exclusive upper bound
            for u = 1 to n + 1 {
                if (idx < Length(text)) {
                    unit = ExtractOneConsonantUnit(text, idx);
                    idx = idx + Length(unit);
                }
            }
        }
        return Substring(text, idx, Length(text) - idx);
    }"
    GetCyrillicVowels "() {
        // Cyrillic vowels (lowercase and uppercase)
        return 'аеёиоуыэюяАЕЁИОУЫЭЮЯ';
    }"
    GetPalatalizingVowels "() {
        // Cyrillic vowels that carry inherent j sound (jotated vowels)
        // я=ja, е=je, ё=jo, ю=ju
        return 'яеёюЯЕЁЮ';
    }"
    StartsWithPalatalizingVowel "(cyrText) {
        // Check if Cyrillic text starts with a palatalizing vowel.
        if (Length(cyrText) = 0) {
            return False;
        }
        firstChar = Substring(cyrText, 0, 1);
        return CharInString(firstChar, GetPalatalizingVowels());
    }"
    IsJotatedVowelOnset "(ipaOnset) {
        // Check if IPA starts with j followed by a vowel (jotated vowel pattern).
        if (Length(ipaOnset) < 2) {
            return False;
        }
        if (Substring(ipaOnset, 0, 1) != 'j') {
            return False;
        }
        secondChar = Substring(ipaOnset, 1, 1);
        return CharInString(secondChar, GetIpaVowels());
    }"
    GetIpaVowels "() {
        // IPA vowels used in Russian transcription
        return 'ɑʌɐeɛɪiouaæɨ';
    }"
    GetStressMarker "() {
        // IPA primary stress marker
        return 'ˈ';
    }"
    IsStressMarker "(c) {
        return(c = 'ˈ');
    }"
    IsTieBar "(c) {
        // Tie bar used in affricates: t͡ʃ, t͡s
        return(c = '͡');
    }"
    IsDiacritic "(c) {
        // IPA diacritics that modify consonants
        // ʲ = palatalized, ː = long, ˑ = half-long, ̟ = advanced, ̃ = nasalized
        diacritics = 'ʲːˑ̟̃';
        return CharInString(c, diacritics);
    }"
    CharInString "(c, str) {
        // Check if character c appears in string str.
        if (Length(str) > 0) {
            for i = 0 to Length(str) {
                if (Substring(str, i, 1) = c) {
                    return True;
                }
            }
        }
        return False;
    }"
    GetSortedPositions "(arr) {
        // Get array indices that have values, in order.
        // Sibelius positions are in ticks (256 per beat), max ~4096 per bar.
        positions = CreateSparseArray();
        count = 0;
        for pos = 0 to 4096 {
            if (arr[pos] != null) {
                positions[count] = pos;
                count = count + 1;
            }
        }
        return positions;
    }"
    StyleIsVerse1 "(styleId) {
        // Verse 1 = Cyrillic text
        return(styleId = 'text.staff.space.hypen.lyrics.verse1');
    }"
    StyleIsVerse2 "(styleId) {
        // Verse 2 = IPA transcription
        return(styleId = 'text.staff.space.hypen.lyrics.verse2');
    }"
    DetectLyricStaves "(score) {
        // Auto-detect staves with lyrics by scanning first 200 bars.
        // Returns array: [startBar, endBar, stavesWithLyrics]
        stavesWithLyrics = CreateSparseArray();
        idx = 0;
        barCount = score.SystemStaff.BarCount;
        checkBars = 200;
        if (barCount < checkBars) {
            checkBars = barCount;
        }
        for each staff in score {
            hasLyrics = False;
            // ManuScript for loops use exclusive upper bound
            for barNum = 1 to checkBars + 1 {
                bar = staff.NthBar(barNum);
                for each obj in bar {
                    if (obj.Type = 'LyricItem') {
                        hasLyrics = True;
                    }
                }
                if (hasLyrics) {
                    barNum = checkBars + 1;
                }
            }
            if (hasLyrics) {
                stavesWithLyrics[idx] = staff.StaffNum;
                idx = idx + 1;
            }
        }
        if (idx = 0) {
            Sibelius.MessageBox('No staves with lyrics found.');
            return null;
        }
        result = CreateSparseArray();
        result[0] = 1;
        result[1] = barCount;
        result[2] = stavesWithLyrics;
        return result;
    }"
}
