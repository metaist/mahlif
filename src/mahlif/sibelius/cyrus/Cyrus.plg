{
	Initialize "() {
AddToPluginsMenu('Cyrus', 'Run');
}"
	Run "() {
score = Sibelius.ActiveScore;
if (null = score) {
	Sibelius.MessageBox('No score is open.');
	return False;
}
result = ShowOptionsDialog(score);
if (result = null) {
	return False;
}
startBar = result[0];
endBar = result[1];
selectedStaves = result[2];
report = ProcessScore(score, startBar, endBar, selectedStaves);
Sibelius.MessageBox(report);
return True;
}"
	ProcessScore "(score, startBar, endBar, selectedStaves) {
report = '';
changeCount = 0;
skippedCount = 0;
boundariesChecked = 0;
numStaves = 0;
for i = 0 to 100 {
	if (selectedStaves[i] = null) {
		i = 100;
	} else {
		numStaves = numStaves + 1;
	}
}
totalBars = (endBar - startBar + 1) * numStaves;
Sibelius.CreateProgressDialog('Processing...', 0, 100);
barsDone = 0;
cancelled = False;
staffIdx = 0;
for each staff in score {
	if (cancelled) {
		staff = null;
	} else {
		isSelected = False;
		for i = 0 to 100 {
			if (selectedStaves[i] = null) {
				i = 100;
			} else {
				if (selectedStaves[i] = staff.StaffNum) {
					isSelected = True;
					i = 100;
				}
			}
		}
		if (isSelected) {
			staffIdx = staffIdx + 1;
			staffName = staff.InstrumentName;
			currentSection = '';
			currentPage = 1;
			for barNum = startBar to endBar + 1 {
				if (not(cancelled)) {
					pct = (barsDone * 100) / totalBars;
					staffProgress = 'Staff ' & staffIdx & '/' & numStaves & ' (' & staffName & ')' & Chr(10) & 'Bar ' & barNum & '/' & endBar;
					continueProcessing = Sibelius.UpdateProgressDialog(pct, staffProgress);
					if (not(continueProcessing)) {
						cancelled = True;
					} else {
						bar = staff.NthBar(barNum);
						displayBarNum = bar.ExternalBarNumberString;
						sysBar = score.SystemStaff.NthBar(barNum);
						for each obj in sysBar {
							if (obj.Type = 'RehearsalMark') {
								currentSection = obj.MarkAsText;
							}
						}
						if (bar.OnNthPage > 0) {
							currentPage = bar.OnNthPage;
						}
						result = ProcessBar(bar, barNum, displayBarNum, currentSection, currentPage, staffName);
						if (Length(result) >= 4) {
							for j = 0 to Length(result) - 3 {
								tag = Substring(result, j, 4);
								if (tag = 'CHNG') {
									changeCount = changeCount + 1;
								}
								if (tag = 'SKIP') {
									endIdx = j + 5;
									numStr = '';
									while (endIdx < Length(result)) {
										ch = Substring(result, endIdx, 1);
										if (ch = '0' or ch = '1' or ch = '2' or ch = '3' or ch = '4' or ch = '5' or ch = '6' or ch = '7' or ch = '8' or ch = '9') {
											numStr = numStr & ch;
											endIdx = endIdx + 1;
										} else {
											endIdx = Length(result);
										}
									}
									if (numStr != '') {
										skippedCount = skippedCount + (0 + numStr);
									}
								}
								if (tag = 'UNRE') {
									boundariesChecked = boundariesChecked + 1;
								}
							}
						}
						if (result != 'SKIP') {
							report = report & result;
						}
					}
					barsDone = barsDone + 1;
				}
			}
		}
	}
}
Sibelius.DestroyProgressDialog();
if (cancelled) {
	Sibelius.MessageBox('Processing cancelled.');
	return header;
}
header = '=== Cyrus Report (build 35) ===' & Chr(10);
header = header & 'Bars: ' & (endBar - startBar + 1) & Chr(10);
header = header & 'Staves: ' & numStaves & Chr(10);
header = header & 'Skipped: ' & skippedCount & Chr(10);
header = header & 'Unresolved: ' & boundariesChecked & Chr(10);
header = header & 'Changes: ' & changeCount & Chr(10);
cleanReport = '';
i = 0;
while (i < Length(report)) {
	if (Substring(report, i, 5) = 'SKIPS') {
		while (i < Length(report) and Substring(report, i, 1) != '|') {
			i = i + 1;
		}
		i = i + 1;
	} else {
		cleanReport = cleanReport & Substring(report, i, 1);
		i = i + 1;
	}
}
fullReport = header & Chr(10) & cleanReport;
filePath = Sibelius.SelectFileToSave('Save Cyrus Report', 'cyrus_report.txt', '', 'txt', 'TEXT');
if (filePath != '') {
	Sibelius.CreateTextFile(filePath);
	Sibelius.AppendTextFile(filePath, fullReport, True);
	Sibelius.MessageBox('Report saved to: ' & filePath);
}
return header;
}"
	ProcessBar "(bar, barNum, displayBarNum, section, page, staffName) {
report = '';
skipCount = 0;
cyrillic = CreateSparseArray();
ipa = CreateSparseArray();
cyrSylType = CreateSparseArray();
for each obj in bar {
	if (obj.Type = 'LyricItem') {
		pos = obj.Position;
		style = obj.StyleId;
		if (StyleIsVerse1(style)) {
			cyrillic[pos] = obj.Text;
			cyrSylType[pos] = obj.SyllableType;
		} else {
			if (StyleIsVerse2(style)) {
				ipa[pos] = obj;
			}
		}
	}
}
positions = GetSortedPositions(cyrillic);
for i = 0 to 1000 {
	pos = positions[i];
	if (pos = null) {
		i = 1000;
	} else {
		cyrText = cyrillic[pos];
		ipaObj = ipa[pos];
		if (ipaObj != null) {
			sylType = cyrSylType[pos];
			if (sylType = MiddleOfWord) {
				nextPos = positions[i + 1];
				if (nextPos != null) {
					nextCyrText = cyrillic[nextPos];
					nextIpaObj = ipa[nextPos];
					if (nextCyrText != null and nextIpaObj != null) {
						result = ProcessSyllableBoundary(cyrText, ipaObj, nextCyrText, nextIpaObj, barNum, displayBarNum, section, page, pos, staffName);
						if (result = 'SKIP') {
							skipCount = skipCount + 1;
						} else {
							report = report & result;
						}
					}
				}
			}
		}
	}
}
if (skipCount > 0) {
	report = 'SKIPS' & skipCount & '|' & report;
}
return report;
}"
	ProcessSyllableBoundary "(cyrA, ipaObjA, cyrB, ipaObjB, barNum, displayBarNum, section, page, pos, staffName) {
ipaA = ipaObjA.Text;
ipaB = ipaObjB.Text;
cyrOnset = ExtractCyrillicOnset(cyrB);
expectedIpa = MapCyrillicToIpa(cyrOnset);
hasStress = False;
ipaBWork = ipaB;
if (Length(ipaB) > 0) {
	fc = Substring(ipaB, 0, 1);
	if (IsStressMarker(fc)) {
		hasStress = True;
		ipaBWork = Substring(ipaB, 1, Length(ipaB) - 1);
	}
}
actualOnset = ExtractIpaOnset(ipaBWork);
if (OnsetMatches(actualOnset, expectedIpa)) {
	return 'SKIP';
}
if (StartsWithPalatalizingVowel(cyrB) and IsJotatedVowelOnset(ipaBWork)) {
	return 'SKIP';
}
unitsToMove = CalculateUnitsToMove(ipaBWork, expectedIpa);
if (unitsToMove = 0) {
	return 'SKIP';
}
if (unitsToMove < 0) {
	beat = (pos / 256) + 1;
loc = 'p' & page;
if (section != '') {
	loc = loc & ' [' & section & ']';
}
loc = loc & ' Bar ' & displayBarNum;
	return 'UNRE ' & loc & ', Beat ' & beat & ', ' & staffName & ': ' & ipaA & '-' & ipaB & ' (cyr: ' & cyrA & '-' & cyrB & ', expected: ' & expectedIpa & ')' & Chr(10);
}
toMove = ExtractConsonantUnits(ipaBWork, unitsToMove);
remaining = Substring(ipaBWork, Length(toMove), Length(ipaBWork) - Length(toMove));
newIpaA = ipaA & toMove;
newIpaB = remaining;
if (hasStress) {
	newIpaB = GetStressMarker() & newIpaB;
}
ipaObjA.Text = newIpaA;
ipaObjB.Text = newIpaB;
beat = (pos / 256) + 1;
loc = 'p' & page;
if (section != '') {
	loc = loc & ' [' & section & ']';
}
loc = loc & ' Bar ' & displayBarNum;
return 'CHNG ' & loc & ', Beat ' & beat & ', ' & staffName & ': ' & ipaA & '-' & ipaB & ' -> ' & newIpaA & '-' & newIpaB & ' (cyr: ' & cyrA & '-' & cyrB & ')' & Chr(10);
}"
	ExtractCyrillicOnset "(text) {
onset = '';
vowels = GetCyrillicVowels();
if (Length(text) > 0) {
	for i = 0 to Length(text) {
		c = Substring(text, i, 1);
		if (CharInString(c, vowels)) {
			return onset;
		}
		onset = onset & c;
	}
}
return onset;
}"
	MapCyrillicToIpa "(cyrOnset) {
if (cyrOnset = 'сч' or cyrOnset = 'зч' or cyrOnset = 'жч') {
	return 'ʃ';
}
result = '';
if (Length(cyrOnset) > 0) {
	for i = 0 to Length(cyrOnset) {
		c = Substring(cyrOnset, i, 1);
		mapped = MapSingleCyrillicConsonant(c);
		result = result & mapped;
	}
}
return result;
}"
	MapSingleCyrillicConsonant "(c) {
if (c = 'п') { return 'p'; }
if (c = 'б') { return 'b'; }
if (c = 'т') { return 't'; }
if (c = 'д') { return 'd'; }
if (c = 'к') { return 'k'; }
if (c = 'г') { return 'g'; }
if (c = 'м') { return 'm'; }
if (c = 'н') { return 'n'; }
if (c = 'р') { return 'r'; }
if (c = 'ф') { return 'f'; }
if (c = 'в') { return 'v'; }
if (c = 'с') { return 's'; }
if (c = 'з') { return 'z'; }
if (c = 'ш') { return 'ʃ'; }
if (c = 'ж') { return 'ʒ'; }
if (c = 'щ') { return 'ʃ'; }
if (c = 'ч') { return 't͡ʃ'; }
if (c = 'ц') { return 't͡s'; }
if (c = 'й') { return 'j'; }
if (c = 'х') { return 'x'; }
if (c = 'л') { return 'l'; }
if (c = 'ь') { return ''; }
if (c = 'ъ') { return ''; }
return '';
}"
	ExtractIpaOnset "(text) {
onset = '';
vowels = GetIpaVowels();
i = 0;
while (i < Length(text)) {
	c = Substring(text, i, 1);
	if (CharInString(c, vowels)) {
		return onset;
	}
	unit = ExtractOneConsonantUnit(text, i);
	onset = onset & unit;
	i = i + Length(unit);
}
return onset;
}"
	ExtractOneConsonantUnit "(text, startIdx) {
if (startIdx >= Length(text)) {
	return '';
}
unit = '';
c = Substring(text, startIdx, 1);
unit = unit & c;
idx = startIdx + 1;
if (idx < Length(text)) {
	nxt = Substring(text, idx, 1);
	if (IsTieBar(nxt)) {
		unit = unit & nxt;
		idx = idx + 1;
		if (idx < Length(text)) {
			nxt = Substring(text, idx, 1);
			unit = unit & nxt;
			idx = idx + 1;
		}
	}
}
while (idx < Length(text)) {
	nxt = Substring(text, idx, 1);
	if (IsDiacritic(nxt)) {
		unit = unit & nxt;
		idx = idx + 1;
	} else {
		idx = Length(text);
	}
}
return unit;
}"
	OnsetMatches "(actualOnset, expectedIpa) {
if (expectedIpa = '') {
	return (actualOnset = '');
}
normalizedActual = NormalizeIpaForMatching(actualOnset);
normalizedExpected = NormalizeIpaForMatching(expectedIpa);
return (normalizedActual = normalizedExpected);
}"
	NormalizeIpaForMatching "(text) {
result = '';
if (Length(text) > 0) {
	for i = 0 to Length(text) {
		c = Substring(text, i, 1);
		if (not(IsDiacritic(c)) and not(IsTieBar(c))) {
			if (c = 'ɫ') {
				result = result & 'l';
			} else {
				if (c = 'ɡ') {
					result = result & 'g';
				} else {
					result = result & c;
				}
			}
		}
	}
}
return result;
}"
	CalculateUnitsToMove "(ipaB, expectedIpa) {
if (expectedIpa = '') {
	onset = ExtractIpaOnset(ipaB);
	return CountConsonantUnits(onset);
}
onset = ExtractIpaOnset(ipaB);
totalUnits = CountConsonantUnits(onset);
normalizedExpected = NormalizeIpaForMatching(expectedIpa);
for unitsToRemove = 0 to totalUnits + 1 {
	remaining = RemoveNConsonantUnits(onset, unitsToRemove);
	normalizedRemaining = NormalizeIpaForMatching(remaining);
	if (normalizedRemaining = normalizedExpected) {
		return unitsToRemove;
	}
}
return -1;
}"
	CountConsonantUnits "(text) {
count = 0;
idx = 0;
while (idx < Length(text)) {
	unit = ExtractOneConsonantUnit(text, idx);
	if (unit = '') {
		idx = Length(text);
	} else {
		count = count + 1;
		idx = idx + Length(unit);
	}
}
return count;
}"
	ExtractConsonantUnits "(text, numUnits) {
result = '';
idx = 0;
if (numUnits > 0) {
	for u = 1 to numUnits + 1 {
		if (idx < Length(text)) {
			unit = ExtractOneConsonantUnit(text, idx);
			result = result & unit;
			idx = idx + Length(unit);
		}
	}
}
return result;
}"
	RemoveNConsonantUnits "(text, n) {
idx = 0;
if (n > 0) {
	for u = 1 to n + 1 {
		if (idx < Length(text)) {
			unit = ExtractOneConsonantUnit(text, idx);
			idx = idx + Length(unit);
		}
	}
}
return Substring(text, idx, Length(text) - idx);
}"
	GetCyrillicVowels "() {
return 'аеёиоуыэюяАЕЁИОУЫЭЮЯ';
}"
	GetPalatalizingVowels "() {
return 'яеёюЯЕЁЮ';
}"
	StartsWithPalatalizingVowel "(cyrText) {
if (Length(cyrText) = 0) {
	return False;
}
firstChar = Substring(cyrText, 0, 1);
return CharInString(firstChar, GetPalatalizingVowels());
}"
	IsJotatedVowelOnset "(ipaOnset) {
if (Length(ipaOnset) < 2) {
	return False;
}
if (Substring(ipaOnset, 0, 1) != 'j') {
	return False;
}
secondChar = Substring(ipaOnset, 1, 1);
return CharInString(secondChar, GetIpaVowels());
}"
	GetIpaVowels "() {
return 'ɑʌɐeɛɪiouaæɨ';
}"
	GetStressMarker "() {
return 'ˈ';
}"
	IsStressMarker "(c) {
return (c = 'ˈ');
}"
	IsTieBar "(c) {
return (c = '͡');
}"
	IsDiacritic "(c) {
diacritics = 'ʲːˑ̟̃';
return CharInString(c, diacritics);
}"
	CharInString "(c, str) {
if (Length(str) > 0) {
	for i = 0 to Length(str) {
		if (Substring(str, i, 1) = c) {
			return True;
		}
	}
}
return False;
}"
	StringContains "(haystack, needle) {
if (needle = '') {
	return True;
}
needleLen = Length(needle);
maxIdx = Length(haystack) - needleLen + 1;
if (maxIdx >= 0) {
	for i = 0 to maxIdx {
		if (Substring(haystack, i, needleLen) = needle) {
			return True;
		}
	}
}
return False;
}"
	GetSortedPositions "(arr) {
positions = CreateSparseArray();
count = 0;
for pos = 0 to 4096 {
	if (arr[pos] != null) {
		positions[count] = pos;
		count = count + 1;
	}
}
return positions;
}"
	StyleIsVerse1 "(styleId) {
return (styleId = 'text.staff.space.hypen.lyrics.verse1');
}"
	StyleIsVerse2 "(styleId) {
return (styleId = 'text.staff.space.hypen.lyrics.verse2');
}"
	ShowOptionsDialog "(score) {
stavesWithLyrics = CreateSparseArray();
idx = 0;
barCount = score.SystemStaff.BarCount;
checkBars = 200;
if (barCount < checkBars) {
	checkBars = barCount;
}
for each staff in score {
	hasLyrics = False;
	for barNum = 1 to checkBars + 1 {
		bar = staff.NthBar(barNum);
		for each obj in bar {
			if (obj.Type = 'LyricItem') {
				hasLyrics = True;
			}
		}
		if (hasLyrics) {
			barNum = checkBars + 1;
		}
	}
	if (hasLyrics) {
		stavesWithLyrics[idx] = staff.StaffNum;
		idx = idx + 1;
	}
}
if (idx = 0) {
	Sibelius.MessageBox('No staves with lyrics found.');
	return null;
}
result = CreateSparseArray();
result[0] = 1;
result[1] = barCount;
result[2] = stavesWithLyrics;
return result;
}"
}
