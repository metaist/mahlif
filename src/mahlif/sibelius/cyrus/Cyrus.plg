{
	Initialize "() {
AddToPluginsMenu('Cyrus', 'Run');
}"
	Run "() {
Sibelius.MessageBox('Cyrus v4 - with ProcessScore');
score = Sibelius.ActiveScore;
if (null = score) {
	Sibelius.MessageBox('No score is open.');
	return False;
}
result = ShowOptionsDialog(score);
if (result = null) {
	return False;
}
startBar = result[0];
endBar = result[1];
selectedStaves = result[2];
report = ProcessScore(score, startBar, endBar, selectedStaves);
Sibelius.MessageBox(report);
return True;
}"
	ProcessScore "(score, startBar, endBar, selectedStaves) {
report = '';
changeCount = 0;
skippedCount = 0;
boundariesChecked = 0;
numStaves = 0;
for i = 0 to 100 {
	if (selectedStaves[i] = null) {
		i = 100;
	} else {
		numStaves = numStaves + 1;
	}
}
totalBars = (endBar - startBar + 1) * numStaves;
Sibelius.CreateProgressDialog('Processing...', 0, 100);
barsDone = 0;
for each staff in score {
	isSelected = False;
	for i = 0 to 100 {
		if (selectedStaves[i] = null) {
			i = 100;
		} else {
			if (selectedStaves[i] = staff.StaffNum) {
				isSelected = True;
				i = 100;
			}
		}
	}
	if (isSelected) {
		staffName = staff.InstrumentName;
		for barNum = startBar to endBar + 1 {
			pct = (barsDone * 100) / totalBars;
			Sibelius.UpdateProgressDialog(pct, staffName & ': Bar ' & barNum & ' of ' & endBar);
			bar = staff.NthBar(barNum);
			result = ProcessBar(bar, barNum, staffName);
			if (Length(result) >= 4) {
				for j = 0 to Length(result) - 3 {
					tag = Substring(result, j, 4);
					if (tag = 'CHNG') {
						changeCount = changeCount + 1;
					}
					if (tag = 'SKIP') {
						skippedCount = skippedCount + 1;
					}
					if (tag = 'UNRE') {
						boundariesChecked = boundariesChecked + 1;
					}
				}
			}
			report = report & result;
			barsDone = barsDone + 1;
		}
	}
}
Sibelius.DestroyProgressDialog();
header = '=== Cyrus Report ===' & Chr(10);
header = header & 'Bars: ' & (endBar - startBar + 1) & Chr(10);
header = header & 'Staves: ' & numStaves & Chr(10);
header = header & 'Skipped: ' & skippedCount & Chr(10);
header = header & 'Unresolved: ' & boundariesChecked & Chr(10);
header = header & 'Changes: ' & changeCount & Chr(10);
return header;
}"
	ProcessBar "(bar, barNum, staffName) {
report = '';
cyrillic = CreateSparseArray();
ipa = CreateSparseArray();
cyrSylType = CreateSparseArray();
for each obj in bar {
	if (obj.Type = 'LyricItem') {
		pos = obj.Position;
		style = obj.StyleId;
		if (StyleIsVerse1(style)) {
			cyrillic[pos] = obj.Text;
			cyrSylType[pos] = obj.SyllableType;
		} else {
			if (StyleIsVerse2(style)) {
				ipa[pos] = obj;
			}
		}
	}
}
positions = GetSortedPositions(cyrillic);
for i = 0 to 1000 {
	pos = positions[i];
	if (pos = null) {
		i = 1000;
	} else {
		cyrText = cyrillic[pos];
		ipaObj = ipa[pos];
		if (ipaObj != null) {
			sylType = cyrSylType[pos];
			if (sylType = MiddleOfWord) {
				nextPos = positions[i + 1];
				if (nextPos != null) {
					nextCyrText = cyrillic[nextPos];
					nextIpaObj = ipa[nextPos];
					if (nextCyrText != null and nextIpaObj != null) {
						result = ProcessSyllableBoundary(cyrText, ipaObj, nextCyrText, nextIpaObj, barNum, pos, staffName);
						report = report & result;
					}
				}
			}
		}
	}
}
return report;
}"
	ProcessSyllableBoundary "(cyrA, ipaObjA, cyrB, ipaObjB, barNum, pos, staffName) {
ipaA = ipaObjA.Text;
ipaB = ipaObjB.Text;
cyrOnset = ExtractCyrillicOnset(cyrB);
expectedIpa = MapCyrillicToIpa(cyrOnset);
hasStress = False;
ipaBWork = ipaB;
if (Length(ipaB) > 0) {
	fc = Substring(ipaB, 0, 1);
	if (IsStressMarker(fc)) {
		hasStress = True;
		ipaBWork = Substring(ipaB, 1, Length(ipaB) - 1);
	}
}
actualOnset = ExtractIpaOnset(ipaBWork);
if (OnsetMatches(actualOnset, expectedIpa)) {
	return 'SKIP';
}
return 'UNRE';
}"
	ExtractCyrillicOnset "(text) {
onset = '';
vowels = GetCyrillicVowels();
if (Length(text) > 0) {
	for i = 0 to Length(text) {
		c = Substring(text, i, 1);
		if (CharInString(c, vowels)) {
			return onset;
		}
		onset = onset & c;
	}
}
return onset;
}"
	MapCyrillicToIpa "(cyrOnset) {
if (cyrOnset = 'сч' or cyrOnset = 'зч' or cyrOnset = 'жч') {
	return 'ʃ';
}
result = '';
if (Length(cyrOnset) > 0) {
	for i = 0 to Length(cyrOnset) {
		c = Substring(cyrOnset, i, 1);
		mapped = MapSingleCyrillicConsonant(c);
		result = result & mapped;
	}
}
return result;
}"
	MapSingleCyrillicConsonant "(c) {
if (c = 'п') { return 'p'; }
if (c = 'б') { return 'b'; }
if (c = 'т') { return 't'; }
if (c = 'д') { return 'd'; }
if (c = 'к') { return 'k'; }
if (c = 'г') { return 'g'; }
if (c = 'м') { return 'm'; }
if (c = 'н') { return 'n'; }
if (c = 'р') { return 'r'; }
if (c = 'ф') { return 'f'; }
if (c = 'в') { return 'v'; }
if (c = 'с') { return 's'; }
if (c = 'з') { return 'z'; }
if (c = 'ш') { return 'ʃ'; }
if (c = 'ж') { return 'ʒ'; }
if (c = 'щ') { return 'ɕ'; }
if (c = 'ч') { return 't͡ʃ'; }
if (c = 'ц') { return 't͡s'; }
if (c = 'й') { return 'j'; }
if (c = 'х') { return 'x'; }
if (c = 'л') { return 'ɫ'; }
if (c = 'ь') { return ''; }
if (c = 'ъ') { return ''; }
return '';
}"
	ExtractIpaOnset "(text) {
onset = '';
vowels = GetIpaVowels();
i = 0;
while (i < Length(text)) {
	c = Substring(text, i, 1);
	if (CharInString(c, vowels)) {
		return onset;
	}
	unit = ExtractOneConsonantUnit(text, i);
	onset = onset & unit;
	i = i + Length(unit);
}
return onset;
}"
	ExtractOneConsonantUnit "(text, startIdx) {
if (startIdx >= Length(text)) {
	return '';
}
unit = '';
c = Substring(text, startIdx, 1);
unit = unit & c;
idx = startIdx + 1;
if (idx < Length(text)) {
	nxt = Substring(text, idx, 1);
	if (IsTieBar(nxt)) {
		unit = unit & nxt;
		idx = idx + 1;
		if (idx < Length(text)) {
			nxt = Substring(text, idx, 1);
			unit = unit & nxt;
			idx = idx + 1;
		}
	}
}
while (idx < Length(text)) {
	nxt = Substring(text, idx, 1);
	if (IsDiacritic(nxt)) {
		unit = unit & nxt;
		idx = idx + 1;
	} else {
		idx = Length(text);
	}
}
return unit;
}"
	OnsetMatches "(actualOnset, expectedIpa) {
if (expectedIpa = '') {
	return (actualOnset = '');
}
normalized = NormalizeIpaForMatching(actualOnset);
return (normalized = expectedIpa);
}"
	NormalizeIpaForMatching "(text) {
result = '';
if (Length(text) > 0) {
	for i = 0 to Length(text) {
		c = Substring(text, i, 1);
		if (not(IsDiacritic(c))) {
			result = result & c;
		}
	}
}
return result;
}"
	CalculateUnitsToMove "(ipaB, expectedIpa) {
if (expectedIpa = '') {
	onset = ExtractIpaOnset(ipaB);
	return CountConsonantUnits(onset);
}
onset = ExtractIpaOnset(ipaB);
totalUnits = CountConsonantUnits(onset);
for unitsToRemove = 0 to totalUnits + 1 {
	remaining = RemoveNConsonantUnits(onset, unitsToRemove);
	normalized = NormalizeIpaForMatching(remaining);
	if (normalized = expectedIpa) {
		return unitsToRemove;
	}
}
if (not(StringContains(NormalizeIpaForMatching(onset), expectedIpa))) {
	return -1;
}
return -1;
}"
	CountConsonantUnits "(text) {
count = 0;
idx = 0;
while (idx < Length(text)) {
	unit = ExtractOneConsonantUnit(text, idx);
	if (unit = '') {
		idx = Length(text);
	} else {
		count = count + 1;
		idx = idx + Length(unit);
	}
}
return count;
}"
	ExtractConsonantUnits "(text, numUnits) {
result = '';
idx = 0;
if (numUnits > 0) {
	for u = 1 to numUnits + 1 {
		if (idx < Length(text)) {
			unit = ExtractOneConsonantUnit(text, idx);
			result = result & unit;
			idx = idx + Length(unit);
		}
	}
}
return result;
}"
	RemoveNConsonantUnits "(text, n) {
idx = 0;
if (n > 0) {
	for u = 1 to n + 1 {
		if (idx < Length(text)) {
			unit = ExtractOneConsonantUnit(text, idx);
			idx = idx + Length(unit);
		}
	}
}
return Substring(text, idx, Length(text) - idx);
}"
	GetCyrillicVowels "() {
return 'аеёиоуыэюяАЕЁИОУЫЭЮЯ';
}"
	GetIpaVowels "() {
return 'ɑʌɐeɛɪiouaæ';
}"
	GetStressMarker "() {
return 'ˈ';
}"
	IsStressMarker "(c) {
return (c = 'ˈ');
}"
	IsTieBar "(c) {
return (c = '͡');
}"
	IsDiacritic "(c) {
diacritics = 'ʲːˑ̟̃';
return CharInString(c, diacritics);
}"
	CharInString "(c, str) {
if (Length(str) > 0) {
	for i = 0 to Length(str) {
		if (Substring(str, i, 1) = c) {
			return True;
		}
	}
}
return False;
}"
	StringContains "(haystack, needle) {
if (needle = '') {
	return True;
}
needleLen = Length(needle);
maxIdx = Length(haystack) - needleLen + 1;
if (maxIdx >= 0) {
	for i = 0 to maxIdx {
		if (Substring(haystack, i, needleLen) = needle) {
			return True;
		}
	}
}
return False;
}"
	GetSortedPositions "(arr) {
positions = CreateSparseArray();
count = 0;
for pos = 0 to 4096 {
	if (arr[pos] != null) {
		positions[count] = pos;
		count = count + 1;
	}
}
return positions;
}"
	StyleIsVerse1 "(styleId) {
return (styleId = 'text.staff.space.hypen.lyrics.verse1');
}"
	StyleIsVerse2 "(styleId) {
return (styleId = 'text.staff.space.hypen.lyrics.verse2');
}"
	ShowOptionsDialog "(score) {
stavesWithLyrics = CreateSparseArray();
idx = 0;
barCount = score.SystemStaff.BarCount;
checkBars = 200;
if (barCount < checkBars) {
	checkBars = barCount;
}
for each staff in score {
	hasLyrics = False;
	for barNum = 1 to checkBars + 1 {
		bar = staff.NthBar(barNum);
		for each obj in bar {
			if (obj.Type = 'LyricItem') {
				hasLyrics = True;
			}
		}
		if (hasLyrics) {
			barNum = checkBars + 1;
		}
	}
	if (hasLyrics) {
		stavesWithLyrics[idx] = staff.StaffNum;
		idx = idx + 1;
	}
}
if (idx = 0) {
	Sibelius.MessageBox('No staves with lyrics found.');
	return null;
}
result = CreateSparseArray();
result[0] = 1;
result[1] = barCount;
result[2] = stavesWithLyrics;
return result;
}"
}
